
  //define the volumes of the sensitive detectors:
  // G4Box* SensDetector = new G4Box("SensitiveDetector", SDet_x, SDet_y, SDet_z);
  // G4LogicalVolume* sensDetector_log[detectorCount*2];
  // G4VPhysicalVolume* sensDetector_phys[detectorCount*2];


// //z dimension iteration: only 2 +/- z
// for(G4int z_dim = 0; z_dim < 2; ++z_dim){
// 	char detName[1024];
// 	sprintf(detName, "SensitiveDetector%d",senscount);

// 	//z offset calculation
// 	if(z_dim != 0){
// 	  offset_z = -(Box_z + SDet_z);
// 	}else{
// 	  offset_z = Box_z + SDet_z;
// 	}

// 	//defines a logical volume
// 	sensDetector_log[senscount] = new G4LogicalVolume(SensDetector,silicon,detName, 0, 0, 0);

// 	//name the detector, and place it in the physical world;
// 	sprintf(detName, "Photodetector%d",senscount);
// 	sensDetector_phys[senscount] =
// 	  new G4PVPlacement(0, G4ThreeVector(offset_x, offset_y, offset_z), sensDetector_log[senscount], detName, logicWorld, true, senscount);

// 	//increase the detector count number;
// 	senscount++;
// }


  // //surfaces~~~~~~~~~~~~~~~~~~~~~~~
  //   //Acrylic TranLoc in Air
  //   //defined the TranLoc Surface
  //   G4OpticalSurface* TranLocSurface = new G4OpticalSurface("AirSurface");
  //   TranLocSurface->SetType(dielectric_dielectric);
  //   TranLocSurface->SetFinish(polished);
  //   TranLocSurface->SetModel(glisur);

  //   //for every member of the LogicalTran
  //   for(auto & c : LogicTran){  
  //     G4LogicalSkinSurface* AirSurface =
  //       new G4LogicalSkinSurface("AirSurface",c,TranLocSurface); //name, logicalVol, OpticalSurface
  //     TranLocSurface = dynamic_cast <G4OpticalSurface*>
  //       (AirSurface->GetSurface(c)->GetSurfaceProperty());
  //     if (TranLocSurface) TranLocSurface->DumpInfo();
  //   }

  //   //define an inner surface for the elements of the tranLoc
  //   G4OpticalSurface* inner_surface = new G4OpticalSurface("InnerSurface");
  //   inner_surface->SetType(dielectric_dielectric);
  //   inner_surface->SetFinish(polished);
  //   inner_surface->SetModel(glisur);

  //   //assign a surface for every placed physical element
  //   for(auto & c : PhysTran){
  //     auto d = c + 1;
  //     //make sure d has an element!
  //     if(d){
  //     G4LogicalBorderSurface* inSurface =
  //     new G4LogicalBorderSurface("InSurface",c , d, inner_surface);
  //     }
  //   }

  // G4OpticalSurface* opticalSurface = dynamic_cast <G4OpticalSurface*>
  //   (inSurface->GetSurface(phys_1, phys_2)->GetSurfaceProperty());
  // if (opticalSurface) opticalSurface->DumpInfo();

  //~~~~~Materials Property Table for Surfaces of Objects~~~~~~~

  // const G4int num = 2;
  // G4double ephoton[num] = {2.034*eV, 4.136*eV};

  // //TranLocSurface
  // G4double refractiveIndex[num] = {1.35, 1.40};

  // G4MaterialPropertiesTable* myST1 = new G4MaterialPropertiesTable();

  // myST1->AddProperty("RINDEX", ephoton, refractiveIndex, num);

  // G4cout << "TranLoc Surface G4MaterialPropertiesTable" << G4endl;
  // myST1->DumpTable();

  // TranLocSurface->SetMaterialPropertiesTable(myST1);

  // //InnerSurface
  // G4double reflectivity[num] = {0.3, 0.5};
  // G4double efficiency[num]   = {0.8, 1.0};

  // G4MaterialPropertiesTable *myST2 = new G4MaterialPropertiesTable();

  // myST2->AddProperty("REFLECTIVITY", ephoton, reflectivity, num);
  // myST2->AddProperty("EFFICIENCY",   ephoton, efficiency,   num);
  // myST2->AddProperty("RINDEX", ephoton, refractiveIndex, num);
  
  // G4cout << "Inner Surfaces G4MaterialPropertiesTable" << G4endl;
  // myST2->DumpTable();

  // inner_surface->SetMaterialPropertiesTable(myST2);

  //2 sensDet Test


  // // sensitive detectors ~~~~~~~~~~~~~~~

  //  //make the newly placed detectors sensitive:
  //  G4SDManager* SDMan = G4SDManager::GetSDMpointer();
  //  G4String SDname;

  //  //must define PhotoDetectorSD!!
  //  G4VSensitiveDetector *photoDetSD = new SensitiveDetector(SDname="/PhotoDetector");
  //  SDMan->AddNewDetector(photoDetSD);

  //  sensDetector_log[0]->SetSensitiveDetector(photoDetSD);
  //  sensDetector_log[1]->SetSensitiveDetector(photoDetSD);
